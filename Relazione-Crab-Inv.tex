\documentclass[a4paper,12pt]{report}

\usepackage{graphicx} % Required for inserting images
\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Relazione-Crab-Inv},
    pdfpagemode=FullScreen,
}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Relazione progetto Crab-Inv}
\author{Mosè Barbieri, Jonathan Crescentini, Jacopo Foschi}
\date{January 2026}

\begin{document}

\maketitle

\tableofcontents


\chapter{Analisi}


\section{Descrizione e requisiti}

Il gruppo si propone di creare un videogioco chiamato "Crab Invaders" ovvero una versione rivisitata 
del videogioco originale "Space Invaders"
\footnote{\url{https://it.wikipedia.org/wiki/Space_Invaders}} 
del 1978. Il videogioco consiste nel controllare un carro armato (il giocatore) per respingere ondate di entità ostili rappresentate da "granchi alieni" (da qui il nome).
\\
Il videogioco è visualizzato in formato 2D, il carro armato si muove a terra (parte bassa dello schermo),  mentre le entità ostili discendono dallo spazio (parte alta dello schermo). L'obiettivo del gioco è quello di respingere i nemici tramite l'arma del veicolo controllato, eliminandoli prima che possano raggiungere la posizione del carro armato ed evitandone eventuali proiettili da essi sparati.
\\
La struttura del gioco è basata sul genere "rogue-lite", ossia ogni tentativo concluso (con successo o meno) permetterà al giocatore di utilizzare le ricompense ottenute per migliorare il proprio veicolo in modo da essere meglio preparato per il tentativo successivo.
\\
Le partite seguono una struttura di livelli predefinita che si susseguono al compimento di quello precedente. 
La condizione di vittoria per poter passare al livello successivo (ed eventualmente "vincere il gioco") è quella di eliminare tutte le entità ostili prima che raggiungano la Terra, pena la perdita di una vita.
%
La condizione di sconfitta che terminerà il tentativo è la fine delle "vite" disponibili al giocatore.
È prevista la possibilità di localizzazione, in modo da permettere di cambiare la lingua dei testi mostrati.

\subsection*{Requisiti funzionali}
\begin{itemize}
	\item Ci dovrà essere un Menu, con la possibilità di : \begin{itemize}
	    \item iniziare una nuova partita
        \item consultare lo storico dei tentativi
        \item usare lo shop
        \item cambiare le impostazioni: \begin{itemize}
        \item la lingua: (per il momento italiano o inglese)
        \item il volume
        \end{itemize}
        \item uscire dal gioco
	\end{itemize}
    \item Il carro armato controllato dal giocatore deve prevedere il movimento sull'asse laterale (sinistra, destra) e la possibilità di "fare fuoco"
	\item I nemici dovranno essere divisi ad ondate all'interno dei livelli, e dovranno essere capaci di muoversi verso il basso e sparare contro il giocatore.
    \item Al termine di ciascuna partita il nuovo stato del profilo del giocatore dovrà essere aggiornato e salvato in modo da garantire l'integrità dei dati
    \item Sarà possibile utilizzare le risorse acquisite durante i tentativi per potenziarsi solo ed esclusivamente tra un tentativo e l'altro, mai durante un tentativo in corso
    
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
	\item Il gioco non dovrà avere grandi requisiti di risorse di sistema, dovrà essere facilmente eseguibile anche su macchine con prestazioni hardware ridotte
\end{itemize}

\newpage

\section{Modello del Dominio}

Il gioco sarà diviso in 3 livelli ben distinti: la meta-progressione, che tiene traccia dei progressi fatti dal giocatore, la run management, che si occuperà di gestire la partita attuale (per run si intende appunto la partita), ed infine il core gameplay, costituito dalle entità in gioco.
\\
La partita dovrà essere composta da vari livelli, inizialmente predeterminati e, se il monte ore lo permette, successivamente generati proceduralmente in modo randomico. Ogni livello sarà quindi composto da ondate che il giocatore dovrà respingere.
\\
Il carro armato dovrà fronteggiare i "granchi alieni", sparandogli col suo cannone e schivando i colpi alieni a lui rivolti. 
%
I nemici caduti rilasceranno una valuta che verrà poi utilizzata per acquistare potenziamenti per il carro armato. Col susseguirsi delle ondate si dovrebbe incontrare una difficoltà tale da perdere se non si hanno sufficienti potenziamenti. 
\definecolor{lie}{HTML}{FAFAFA}
\textcolor{lie}{(skill issue)} %DA TOGLIERE%
\\
%
Proseguendo sempre di più nei livelli si potrà, infine, finire il gioco, scacciando definitivamente gli invasori.
\\
Gli elementi costitutivi del dominio nella sintesi dei 3 livelli sono visibili nella figura \ref{img:analysis}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{img/modelloDominio.png}
    \caption{Schema UML dell'analisi del dominio, con rappresentate tutti e 3 i livelli del gioco. La meta-progression: rappresentata da Save, UserProfile, Shop e PowerUp. La Run Management: descritta da GameSession, Level e Entity. Ed infinte il livello di gameplay. Rappresentato da entity e tutto ciò che ne deriva}
    \label{img:analysis}
\end{figure}

\chapter{Design}

\section{Architettura}

L'architettura del gioco è strutturata col pattern MVC.

\section{Design dettagliato}

\subsection{Design Foschi}

\subsubsection{Sincronizzazione dello stato della localizzazione}

\paragraph{Problema}
Per garantire che tutte le sezioni dell’interfaccia grafica condividessero uno stato coerente della lingua, era necessario centralizzare l’accesso alle stringhe localizzate.

\paragraph{Soluzione provata}
Ho implementato il pattern singleton, perché in questo contesto è corretto avere una sola istanza di Localization per client. Questo approccio mi ha permesso di creare un'unica istanza di Localization, che funge da servizio globale per recuperare le stringhe dai ResourceBundle. In questo modo, lo stato della lingua rimaneva coerente in tutta l'applicazione.

\paragraph{Problemi generati}
L'uso di questo pattern, ha reso complicato il testing unitario, e ha reso problematica la gestione del codice qualora si volesse aggiungere il multithreading. Inoltre questo pattern imponeva l'inizializzazione con un ResourceBundle di default, in piena contraddizione con la pratica di scegliere la lingua alla prima apertura del gioco.

\paragraph{Soluzione}
La classe è stata rielaborata con l'approccio single instance by design. Questo permette di mantenere uno stato consistente per tutta la GUI, ma l'istanza è accessibile solo dai componenti che la ricevono esplicitamente, invece di essere disponibile globalmente. Questo rende anche molto più semplice il testing automatico, perché permette di avere situazioni di partenza diverse senza dover modificare manualmente lo stato dell'istanza.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/localization.png}
    \caption{Qui lo schema UML del design della localizzazione}
    \label{fig:localization}
\end{figure}

\subsubsection{Gestione del suono}

\paragraph{Problema}
Gestire il suono in maniera uniforme per tutta l'esecuzione del gioco senza dipendere completamente da JavaFX

\paragraph{Soluzione}
Si è fatto uso come nella sezione precedente di un singleton, anch'esso poi corretto da un approccio single instance by design. Per lo sviluppo è stato utilizzato il pattern facade creando quindi l'interfaccia SoundService, per fare in modo che il controller non sapesse nulla dell'esistenza di JavaFX e che potesse quindi eseguire qualsiasi model con qualsiasi libreria che implementasse l'interfaccia di facciata.

\begin{figure}[H]
    \centering
        \includegraphics[width=\linewidth]{img/soundServiceFacade.png}
    \caption{Schema UML che mostra la progettazione fatta con solo i metodi principali}
    \label{img:audiofacade}
\end{figure}

\subsubsection{Strutturazione delle entità}

\paragraph{Problema}
Le entità del gioco hanno tutte un comportamento base pressoché identico e vi sarebbe perciò una grande ripetizione di codice.

\paragraph{Soluzione}
A risoluzione di ciò è stata progettata una classe astratta per tutte le entità che implementa tutti i metodi che esse devono avere, lasciando poi la possibilità a chi la eredita di specializzarla.

\begin{figure}[H]
    \centering
        \includegraphics[width=0.6\linewidth]{img/entity.png}
    \caption{Schema UML della progettazione delle entità con alcuni dei metodi che esse implementano come esempio}
    \label{img:entity}
\end{figure}

\subsubsection{Standardizzazione dei controller dell'entità}

\paragraph{Problema}
In sede di sviluppo si è rilevato come i controller per le entità abbiano un comportamento pressoché identico eccezion fatta per il metodo update. Che ha lo scopo di fornire un update dello stato dell'entità ad ogni tick.

\paragraph{Soluzione}
Strutturare un controller astratto che fornisca implementazione per tutti i metodi in comune a tutte le entità specializzando poi all'occorrenza. La differenza nel metodo update è stata invece gestita creando due interfacce apposite con la propria versione di update. Metterli entrambi in overload come metodi astratti avrebbe portato obbligatoriamente ed erroneamente a dover implementare entrambi i metodi. In questo modo invece non si è costretti a farlo mantenendo quindi il codice pulito nel suo scopo.

\begin{figure}[H]
    \centering
        \includegraphics[width=\linewidth]{img/entityController.png}
    \caption{Schema UML della progettazione degli EntityController mostrando alcuni metodi come esempio}
    \label{img:entityController}
\end{figure}

\subsection{Design Barbieri}

\subsubsection{Gestione delle Wave}

\paragraph{Problema:}
L'interfaccia fatta inizialmente non basta per gestire la progressione delle Wave pensata da noi. 
\paragraph{Soluzione:}
Quindi è necessario introdurre nel dominio un WaveProvider, con l'obbiettivo di fornire Wave a Level.
%
Questo permette di separare la logica di progressione e le singole ondate, mantenendo così il dominio stabile.Il WaveProvider è modellato tramite Strategy Pattern, così permettendo di cambiare il modo in qui sono fatte le Wave in un secondo momento e senza modificare il Level.

\begin{figure}[H]
    \centering
    \includegraphics{img/WaveProvider.png}
    \caption{Schema UML di parte del dominio, che mostra l'interfaccia di implementazione di Wave provider}
    \label{img:waveprovider}
\end{figure}

\subsubsection{La Generazione di nemici}

\paragraph{Problema:}
Nell'interfaccia iniziale esistevavo semplicemente i nemici quindi manca qualcosa che effettivamente li generi secondo il tipo di essi.
\paragraph{Soluzione:}
Quindi è necessaria una EnemyFactory che prenda il tipo di enemy, basandosi sul pattern Factory.
%
Questo permette di separare la logica di progressione e le singole ondate, mantenendo così il dominio stabile.Il WaveProvider è modellato tramite Strategy Pattern, così permettendo di cambiare il modo in qui sono fatte le Wave in un secondo momento e senza modificare il Level.

\begin{figure}[H]
    \centering
     \includegraphics[width=0.95\linewidth]{img/EnemyFactory.png}
    \caption{Schema UML di parte del dominio che mostra l'interfaccia di EnemyFactory e come interagisce con l'EnemyType che è l'enum con la tipologia di nemici.}
    \label{img:EnemyFactory}
\end{figure}

\subsubsection{La currency}

\paragraph{Problema:}
All'interno del modello di dominio iniziale non è presente qualcosa che applichi l'aumento della moneta spendibile del giocatore.
\paragraph{Soluzione:}
Perciò ho ritenuto necessario aggiungere ai singoli la quantità della ricompensa e poi creare un servizio che faccia da tramite tra quello e lo userProfile.

\begin{figure}[H]
    \centering
     \includegraphics[width=0.95\linewidth]{img/rewardSystem.png}
    \caption{Schema UML di parte del dominio che mostra le interfacce modificate e come si collega con il resto della parte del dominio.}
    \label{img:rewardSystem}
\end{figure}


\chapter{Sviluppo}

\section{Testing automatizzato}
Il testing automatico è stato sproporzionato nei vari membri del gruppo, dove alcuni ne hanno fatto meno uso e in maniera meno estensiva. Si è cercato di praticare il TDD ma la grande maggioranza dei test è stata fatta in modalità test-after. 
\\
Soggetto dei test sono state le parti di model e di controller. Con test appositi anche per la persistenza dei dati e quindi dei salvataggi. A questo fine si è fatto uso della libreria JUnit e in un'istanza specifica, ovvero per il testing del controller dell'audio, anche della libreria Mockito. Questa libreria è stata utilizzata in quanto il model audio fa uso di costrutti di JavaFX, in questo modo è stato possibile controllare logicamente in contesto di mocking che il controller funzionasse adeguatamente.
\\
Non è stato fatto testing automatico della view JavaFX perché sarebbe stato necessario fare uso di una libreria che non è mai stata trattata nel corso, il cui apprendimento e successiva integrazione non ci è stato possibile nel monte ore prefissato. 

\section{Note di sviluppo}

\subsection{Note di sviluppo Foschi}

\subsubsection{Utilizzo della libreria JavaFX}
Utilizzata per fare la view del gioco e la gestione dei suoni. Qui un esempio
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/View/LanguageSelection.java#L41-L54}{Permalink}

\subsubsection{Utilizzo della libreria Mockito}
Utilizzata per fare mocking nello unit testing di oggetti JavaFX nell'AudioController
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/a89f17297b4dfa64e1ed1c547fb00e598e52e54b/src/test/java/it/unibo/crabinv/Controller/audio/TestAudioController.java#L23-L26}{Permalink}

\subsubsection{Utilizzo della libreria Lombok}
Utilizzata per automatizzare la creazione dei builder delle entità
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/20d4b39be68c6062d0f374d1ceb9e9b4058d9a4d/src/main/java/it/unibo/crabinv/Model/entities/entity/AbstractEntity.java#L9}{Permalink}

\subsubsection{Utilizzo dei resource boundle}
Utilizzati per garantire un supporto multilingua efficiente
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/Model/i18n/Localization.java#L40}{Permalink}

\subsubsection{Utilizzo di method inference}
Usati in più parti del codice, qui un esempio.
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/View/Settings.java#L50-L51}{Permalink}

\subsubsection{Utilizzo di lambda expressions}
Per fornire i metodi necessari senza ricorrere a classi anonime. Utilizzato in varie parti del codice, qui un esempio.
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/View/Settings.java#L64}{Permalink}

\subsubsection{Utilizzo della libreria Gson}
Per gestire la permanenza delle impostazioni del gioco
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/config/SettingsFileManager.java#L33}{Permalink}

\subsubsection{Utilizzo del costrutto record}
Per facilitare il salvataggio delle impostazioni del gioco
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/config/AppSettings.java#L10-L30}{Permalink}

\subsection{Note di sviluppo Barbieri}

\subsubsection{Utilizzo della libreria JavaFX}
Utilizzata per creare il menu
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/View/MainMenu.java#L1-L47}{Permalink}

\subsubsection{Utilizzo di Stream}

Utilizzati per ciclare su tutta la lista di nemici
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/Model/Enemies/WaveImpl.java#L69}{Permalink}

\subsubsection{Utilizzo di Method Inference}

Utilizzato inseme allo stream
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/blob/7e2387f37e84d412baba83f064e505c5f91b9d32/src/main/java/it/unibo/crabinv/Model/Enemies/WaveImpl.java#L69}{Permalink}

Precisazione i due permalink precedenti sono inerenti a Johnatan Crescentini ma è perché dopo a fatto prima a fare un nuovo file per sistemare delle cose per il Game Engine. Questo è il commit dove l'ho fatto io sul file iniziale: 
\href{https://github.com/JacopoFoschi2/PSS25-crab-inv/commit/ddea3d288a5cc7808e3c584ecca006d3e9645f0b#diff-6a448310d2a77abb6b264f973fce2c6a79de74d82a8caca7d456e5c03000c9cd}{CommitLink}

\subsection{Parti riadattate dal codice:}

Alcuni metodi specifici della view, come il createMenuButton: 
\href{}{Permalink}
\\
Ed Il metodo createPowerUpRow: 
\href{}{Permalink}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

\subsubsection{Autovalutazione Foschi}
Lo svolgimento di questo progetto è stato complicato. Non avevamo mai fatto un lavoro di così grandi dimensioni e mi sono trovato in seria difficoltà all'inizio ad orientarmi in tutti gli step di progettazione del software.
\\
Lo sviluppo è stato ulteriormente complicato dal fatto che, a causa di altri impegni dei miei compagni, mi sono trovato per praticamente tutto lo sviluppo ad essere qualche giornata di lavoro avanti rispetto a loro. Coordinarsi è quindi stato più difficile di quanto avrei voluto e mi sono trovato molto spesso a strutturare framework che sono stati poi utilizzati dai miei compagni. A causa di queste circostanze mi sono impegnato a produrre del codice il più facile da implementare o utilizzare possibile, cosa che mi ha permesso di fare molta esperienza sul campo di ciò che dovrebbe essere del codice ben fatto. Riguardo alla gestione del tempo a malincuore non è stato possibile consegnare in tempo. Ritengo che ciò sia dovuto ad una sottostima fatta nella complessità e tempo necessario per lo svolgimento di alcuni punti fondamentali quali il gameloop dettata dalla nostra inesperienza. Sono tutt'ora insoddisfatto di ciò, ma mi servirà da lezione per eventuali progetti futuri.

\subsubsection{Autovalutazione Barbieri}
Il progetto è stato complesso. Avevo fatto qualcosa di progettazione, in altri contesti, ma come junior dev: solo a livello di richieste e poi implementazione quindi niente di profondo. Al termine di questo progetto mi sento ovviamente più preparato ad un lavoro di effettiva analisi iniziale e solo poi arrivare al codice effettivo.
\\
In generale penso di poter fare meglio, a livello di codice ed anche di progettazione, a livello di pattern sono riuscito a trovare qualcosa che potesse essere utile al progetto ma comunque non avendo un'esperienza tale da permettermi di giudicare tutto quello che ho fatto, obiettivamente, io penso di aver fatto quello che potevo fare nel tempo a disposizione. Sicuramente ho migliorato la mia capacità di progettazione e la valutazione delle tempistiche. Nel complesso è stata un'esperienza dura, ma che ha formato

\section{Difficoltà incontrate e commenti per i docenti}
Come gruppo ci siamo trovati impreparati ad affrontare un lavoro di progettazione di questo livello. Perché riteniamo che nell'effettivo non ci siano stati ripartiti sufficienti insegnamenti a riguardo. Abbiamo perciò dovuto imparare molte cose in corso d'opera, portandoci anche a commettere errori altrimenti evitabili. Ci siamo sentiti costretti a ricorrere a LLM e guide online, non tanto per l'implementazione del codice, quanto per chiedere consigli di progettazione, informandoci su ciò che viene normalmente applicato allo stato dell'arte. Ci sentiamo di consigliare caldamente ai docenti di porre una maggiore attenzione quindi alla progettazione del codice in sé, per quanto possiamo capire che i limiti di tempo sono quelli che sono, sarebbe di grande aiuto per gli studenti futuri.

\appendix
\chapter{Guida utente}
Note: In quanto immaginiamo che avere cartelle inutili possa causare fastidio notifichiamo ai professori che l'utilizzo di questa demo porterà alla creazione di una cartella .crabinvaders nella propria userFolder.

La navigazione della UI può essere svolta sia col Tab che con le frecce direzionali. La selezione può essere fatta sia con Spazio che con Invio.
I comandi del giocatore sono Freccia Sinistra per muoversi a sinistra, Freccia Destra per muoversi a destra, SPAZIO per sparare e Esc per mettere in pausa.

\end{document}
