\documentclass[a4paper,12pt]{report}

\usepackage{graphicx} % Required for inserting images
\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Relazione-Crab-Inv},
    pdfpagemode=FullScreen,
}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Relazione progetto Crab-Inv}
\author{Mosè Barbieri, Jonathan Crescentini, Jacopo Foschi}
\date{January 2026}

\begin{document}

\maketitle

\tableofcontents


\chapter{Analisi}


\section{Descrizione e requisiti}

Il gruppo si propone di creare un videogioco chiamato "Crab Invaders" ovvero una versione rivisitata 
del videogioco originale "Space Invaders"
\footnote{\url{https://it.wikipedia.org/wiki/Space_Invaders}} 
del 1978. Il videogioco consiste nel controllare un carro armato (il giocatore) per respingere ondate di entità ostili rappresentate da "granchi alieni" (da qui il nome).
\\
Il videogioco è visualizzato in formato 2D, il carro armato si muove a terra (parte bassa dello schermo),  mentre le entità ostili discendono dallo spazio (parte alta dello schermo). L'obiettivo del gioco è quello di respingere i nemici tramite l'arma del veicolo controllato, eliminandoli prima che possano raggiungere la posizione del carro armato ed evitandone eventuali proiettili da essi sparati.
\\
La struttura del gioco è basata sul genere "rogue-lite", ossia ogni tentativo concluso (con successo o meno) permetterà al giocatore di utilizzare le ricompense ottenute per migliorare il proprio veicolo in modo da essere meglio preparato per il tentativo successivo.
\\
Le partite seguono una struttura di livelli predefinita che si susseguono al compimento di quello precedente. 
La condizione di vittoria per poter passare al livello successivo (ed eventualmente "vincere il gioco") è quella di eliminare tutte le entità ostili prima che raggiungano la Terra, pena la perdita di una vita.
%
La condizione di sconfitta che terminerà il tentativo è la fine delle "vite" disponibili al giocatore.
È prevista la possibilità di localizzazione, in modo da permettere di cambiare la lingua dei testi mostrati.

\subsection*{Requisiti funzionali}
\begin{itemize}
	\item Ci dovrà essere un Menu, con la possibilità di : \begin{itemize}
	    \item fare una nuova partita (che cancella una eventualmente già esistente)
        \item caricare una partita non finita
        \item consultare lo storico dei tentativi
        \item usare lo shop
        \item uscire dal gioco
        \item cambiare le impostazioni: \begin{itemize}
        \item il volume
        \item la lingua: (italiano o inglese)
        \end{itemize}
	\end{itemize}
    \item Il carro armato controllato dal giocatore deve prevedere il movimento sull'asse laterale (sinistra, destra) e la possibilità di "fare fuoco"
	\item I nemici dovranno essere divisi ad ondate all'interno dei livelli, e dovranno essere capaci di muoversi verso il basso e sparare contro il giocatore.
    \item I tentativi potranno essere salvati automaticamente alla fine di ogni livello in modo da poter riprendere a giocare in un secondo momento
    \item Sarà possibile utilizzare le risorse acquisite durante i tentativi per potenziarsi solo ed esclusivamente tra un tentativo e l'altro, mai durante un tentativo in corso
    
\end{itemize}

\subsection*{Requisiti non funzionali}
\begin{itemize}
	\item Il gioco non dovrà avere grandi requisiti di risorse di sistema, dovrà essere facilmente eseguibile anche su macchine con prestazioni hardware ridotte
\end{itemize}


\newpage
\section{Modello del Dominio}

Il gioco sarà diviso in 3 livelli ben distinti: la meta-progressione, che tiene traccia dei progressi fatti dal giocatore, la run management, che si occuperà di gestire la partita attuale (per run si intende appunto la partita), ed infine il core gameplay, costituito dalle entità in gioco.
\\
La partita dovrà essere composta da vari livelli, inizialmente predeterminati e, se il monte ore lo permette, successivamente generati proceduralmente in modo randomico. Ogni livello sarà quindi composto da ondate che il giocatore dovrà respingere.
\\
Il carro armato dovrà fronteggiare i "granchi alieni", sparandogli col suo cannone e schivando i colpi alieni a lui rivolti. 
%
I nemici caduti rilasceranno una valuta che verrà poi utilizzata per acquistare potenziamenti per il carro armato. Col susseguirsi delle ondate si dovrebbe incontrare una difficoltà tale da perdere se non si hanno sufficienti potenziamenti. 
\definecolor{lie}{HTML}{FAFAFA}
\textcolor{lie}{(skill issue)} %DA TOGLIERE%
\\
%
Proseguendo sempre di più nei livelli si potrà, infine, finire il gioco, scacciando definitivamente gli invasori.
\\
Gli elementi costitutivi del dominio nella sintesi dei 3 livelli sono visibili nella figura \ref{img:analysis}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{img/modelloDominio.png}
    \caption{Schema UML dell'analisi del dominio, con rappresentate tutti e 3 i livelli del gioco. La meta-progression: rappresentata da Save, UserProfile, Shop e PowerUp. La Run Management: descritta da GameSession, Level e Entity. Ed infinte il livello di gameplay. Rappresentato da entity e tutto ciò che ne deriva}
    \label{img:analysis}
\end{figure}

\chapter{Design}

\section{Architettura}

L'architettura del gioco è strutturata col pattern MVC.

\section{Design dettagliato}

\subsection{Design Foschi}

\subsubsection{Sincronizzazione dello stato della localizzazione}

\paragraph{Problema}
Per garantire che tutte le sezioni dell’interfaccia grafica condividessero uno stato coerente della lingua, era necessario centralizzare l’accesso alle stringhe localizzate.

\paragraph{Soluzione 1}
Ho implementato il pattern singleton, perché in questo contesto è corretto avere una sola istanza di Localization per client. Questo approccio mi ha permesso di creare un'unica istanza di Localization, che funge da servizio globale per recuperare le stringhe dai ResourceBundle. In questo modo, lo stato della lingua rimaneva coerente in tutta l'applicazione.

\paragraph{Problemi generati}
L'uso di questo pattern, ha reso complicato il testing unitario, e ha reso problematica la gestione del codice qualora si volesse aggiungere il multithreading. Inoltre questo pattern imponeva l'inizializzazione con un ResourceBundle di default, in piena contraddizione con la pratica di scegliere la lingua alla prima apertura del gioco.

\paragraph{Soluzione}
La classe è stata rielaborata con l'approccio single instance by design. Questo permette di mantenere uno stato consistente per tutta la GUI, ma l'istanza è accessibile solo dai componenti che la ricevono esplicitamente, invece di essere disponibile globalmente. Questo rende anche molto più semplice il testing automatico, perché permette di avere situazioni di partenza diverse senza dover modificare manualmente lo stato dell'istanza.

\subsubsection{Gestione del suono}

\paragraph{Problema}
Gestire il suono in maniera uniforme per tutta l'esecuzione del gioco senza dipendere completamente da JavaFX

\paragraph{Soluzione}
Si è fatto uso come nella sezione precedente di un singleton, anch'esso poi corretto da un single instance by design. Per lo sviluppo è stato utilizzato il pattern facade per fare in modo che il controller non sapesse nulla dell'esistenza di JavaFX e che potesse quindi eseguire qualsiasi model con qualsiasi libreria che implementasse l'interfaccia di facciata.

\begin{figure}[H]
    \centering
        \includegraphics[width=\linewidth]{img/soundServiceFacade.png}
    \caption{Schema UML che mostra l'implementazione fatta}
    \label{img:audiofacade}
\end{figure}

\subsubsection{Gestione delle immagini nella selezione della lingua}

\paragraph{Problema}
L'interfaccia di selezione della lingua deve avere dei bottoni che scalano in base al numero di lingue supportate e le dimensioni dello schermo

\paragraph{Soluzione provata}
La prima soluzione provata è stata quella di fare uso di SVG. È stato tentato di fare uso prima di batik e poi di SVGSalamander, ma il loro utilizzo si è rivelato molto più complicato del previsto e non sono riuscito a trovare un implementazione funzionasse senza usare del codice preso da altri.

\paragraph{Soluzione}
Seppur ci sia un concreto rischio di produrre risultati non pienamente gradevoli all'occhio ho deciso di fare uso di png. Questa scelta ha semplificato non poco tutta la gestione dell'immagine in quanto nativa a JavaFX consentendomi di trovare una soluzione che fosse di mia provenienza.

\subsection{Design Barbieri}

\subsubsection{Gestione delle Wave}

\paragraph{Problema:}
L'interfaccia fatta inizialmente non basta per gestire la progressione delle Wave pensata da noi. 
\paragraph{Soluzione:}
Quindi è necessario introdurre nel dominio un WaveProvider, con l'obbiettivo di fornire Wave a Level.
%
Questo permette di separare la logica di progressione e le singole ondate, mantenendo così il dominio stabile.Il WaveProvider è modellato tramite Strategy Pattern, così permettendo di cambiare il modo in qui sono fatte le Wave in un secondo momento e senza modificare il Level.

\begin{figure}[H]
    \centering
    \includegraphics{img/WaveProvider.png}
    \caption{Schema UML di parte del dominio, che mostra l'interfaccia di implementazione di Wave provider}
    \label{img:waveprovider}
\end{figure}

\subsubsection{La Generazione di nemici}

\paragraph{Problema:}
Nell'interfaccia iniziale esistevavo semplicemente i nemici quindi manca qualcosa che effettivamente li generi secondo il tipo di essi.
\paragraph{Soluzione:}
Quindi è necessaria una EnemyFactory che prenda il tipo di enemy, basandosi sul pattern Factory.
%
Questo permette di separare la logica di progressione e le singole ondate, mantenendo così il dominio stabile.Il WaveProvider è modellato tramite Strategy Pattern, così permettendo di cambiare il modo in qui sono fatte le Wave in un secondo momento e senza modificare il Level.

\begin{figure}[H]
    \centering
     \includegraphics[width=0.95\linewidth]{img/EnemyFactory.png}
    \caption{Schema UML di parte del dominio che mostra l'interfaccia di EnemyFactory e come interagisce con l'EnemyType che è l'enum con la tipologia di nemici.}
    \label{img:waveprovider}
\end{figure}

\subsubsection{La currency}

\paragraph{Problema:}
All'interno del modello di dominio iniziale non è presente qualcosa che applichi l'aumento della moneta spendibile del giocatore.
\paragraph{Soluzione:}
Perciò ho ritenuto necessario aggiungere ai singoli la quantità della ricompensa e poi creare un servizio che faccia da tramite tra quello e lo userProfile.

\begin{figure}[H]
    \centering
     \includegraphics[width=0.95\linewidth]{img/rewardSystem.png}
    \caption{Schema UML di parte del dominio che mostra le interfacce modificate e come si collega con il resto della parte del dominio.}
    \label{img:waveprovider}
\end{figure}


\chapter{Sviluppo}

\section{Testing automatizzato}
Il testing automatico è stato sproporzionato nei vari membri del gruppo, dove alcuni ne hanno fatto meno uso e in maniera meno estensiva. La maggioranza dei test è stata fatta in modalità test-after ma si è anche cercato di praticare il tdd. 
\\
Soggetto dei test sono state soprattutto le parti di model e di controller. Con test appositi anche per la persistenza dei dati e quindi dei salvataggi. A questo fine si è fatto uso della libreria JUnit e in un'istanza specifica, ovvero per il testing del controller dell'audio, anche della libreria Mockito. Questa libreria è stata utilizzata in quanto il model audio fa uso di costrutti di JavaFX, in questo modo è stato possibile controllare logicamente in contesto di mocking che il controller funzionasse adeguatamente.
\\
Non è stato possibile fare testing di javaFX perché sarebbe stato necessario fare uso di una libreria che non è mai stata trattata nel corso, il cui apprendimento e successiva integrazione non ci avrebbe permesso di rispettare il monte ore prefissato. 

\section{Note di sviluppo}

\subsection{Note di sviluppo Foschi}

\subsubsection{Utilizzo della libreria JavaFX}
Utilizzata per fare la view del gioco e la gestione dei suoni
\href{}{Permalink}

\subsubsection{Utilizzo della libreria Mockito}
Utilizzata per fare unit testing di oggetti JavaFX
\href{}{Permalink}

\subsubsection{Utilizzo dei resource boundle}
Utilizzati per garantire un supporto multilingua efficiente
\href{}{Permalink}

\subsubsection{Utilizzo di method inference}
Usato per costruire metodi coi generici
\href{}{Permalink}

\subsubsection{Utilizzo di lamba expressions}
Per fornire i metodi necessari senza ricorrere a classi anonime
\href{}{Permalink}

\subsubsection{Utilizzo della libreria Gson}
Per gestire la permanenza delle impostazioni del gioco
\href{}{Permalink}

\subsubsection{Utilizzo del costrutto record}
Per facilitare il salvataggio delle impostazioni del gioco
\href{}{Permalink}

\subsubsection{Utilizzo di stream}
Per recuperare immagini in modo rapido
\href{}{Permalink}

\subsection{Note di sviluppo Barbieri}

\subsubsection{Utilizzo della libreria JavaFX}
Utilizzata per creare il menu ed anche il gameplay
\href{}{Permalink}

\subsubsection{Utilizzo di Stream}

Utilizzati per ciclare su tutta la lista di nemici
\href{}{Permalink}

\subsubsection{Utilizzo di Method Inference}

Utilizzato inseme allo stream
\href{}{Permalink}

\subsubsection{Utilizzo di Lambda Expressions}

Utilizzato per il menu
\href{}{Permalink}

\chapter{Commenti finali}

\section{Autovalutazione e lavori futuri}

\subsubsection{Autovalutazione Foschi}
Lo svolgimento di questo progetto è stato complicato. Non avevamo mai fatto un lavoro di così grandi dimensioni e mi sono trovato in seria difficoltà all'inizio ad orientarmi in tutti gli step di progettazione del software.
\\
Lo sviluppo è stato ulteriormente complicato dal fatto che, a causa di altri impegni dei miei compagni, mi sono trovato per praticamente tutto lo sviluppo ad essere qualche giornata di lavoro avanti rispetto a loro. Coordinarsi è quindi stato più difficile di quanto avrei voluto e mi sono trovato molto spesso a strutturare framework che sono stati poi utilizzati dai miei compagni. A causa di queste circostanze mi sono impegnato a produrre del codice il più facile da implementare o utilizzare possibile, cosa che mi ha permesso di fare molta esperienza sul campo di ciò che dovrebbe essere del codice ben fatto.

\subsubsection{Autovalutazione Barbieri}
Il progetto è stato complesso. Avevo fatto qualcosa di progettazione, in altri contesti, ma come junior dev: solo a livello di richieste e poi implementazione quindi niente di profondo. Al termine di questo progetto mi sento ovviamente più preparato ad un lavoro di effettiva analisi iniziale e solo poi arrivare al codice effettivo.
\\
In generale penso di poter fare meglio, a livello di codice ed anche di progettazione, a livello di pattern sono riuscito a trovare qualcosa che potesse essere utile al progetto ma comunque non avendo un'esperienza tale da permettermi di giudicare tutto quello che ho fatto, obiettivamente, io penso di aver fatto quello che potevo fare nel tempo a disposizione. Sicuramente ho migliorato la mia capacità di progettazione e la valutazione delle tempistiche. Nel complesso è stata un'esperienza dura, ma che ha formato

\section{Difficoltà incontrate e commenti per i docenti}
Come gruppo ci siamo trovati impreparati ad affrontare un lavoro di progettazione di questo livello. Perché riteniamo che nell'effettivo non ci siano stati ripartiti sufficienti insegnamenti a riguardo. Abbiamo perciò dovuto imparare molte cose in corso d'opera, portandoci anche a commettere errori altrimenti evitabili. Ci siamo sentiti costretti a ricorrere a LLM e guide online, non tanto per l'implementazione del codice, quanto per chiedere consigli di progettazione, informandoci su ciò che viene normalmente applicato allo stato dell'arte. Ci sentiamo di consigliare caldamente ai docenti di porre una maggiore attenzione quindi alla progettazione del codice in sè, per quanto possiamo capire che i limiti di tempo sono quelli che sono, sarebbe di grande aiuto per gli studenti futuri.

\appendix
\chapter{Guida utente}
Note: In quanto immaginiamo che avere cartelle inutili possa causare fastidio notifichiamo ai professori che l'utilizzo di questa demo porterà alla creazione di una cartella .crabinvaders nella propria userFolder.

La navigazione della UI può essere svolta sia col Tab che con le frecce direzionali. La selezione può essere fatta sia con Spazio che con Invio.
I comandi del giocatore sono A per muoversi a sinistra, D per muoversi a destra, SPAZIO per sparare e Esc per mettere in pausa.

\end{document}
